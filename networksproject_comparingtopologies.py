# -*- coding: utf-8 -*-
"""NetworksProject-ComparingTopologies.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1KNWWIOQo8e9JCzVtxY1e3HPokeC2hrtt
"""

!pip install networkx
!pip install matplotlib

import networkx as nx
import matplotlib.pyplot as plt

"""# Topology Creation
- Fat-Tree
"""

#Given k, construct a graph in networkX that represents k-fat tree
def make_fat_tree(k):
  G = nx.Graph()

  #k: each switch has k ports
  num_ports = k
  num_core_switches = (k/2)^2
  num_pods = k

  #each pod consists of (k/2) aggregation switches and (k/2) edge switches
  num_aggregation_switches = k/2
  num_edge_switches = k/2

  pods = {}
  for i in num_pods:
    
    #add core switches
    for j in range(num_core_switch_per_pod):
      G.add_node(j)


  
  #draws graph G from above
  nx.draw(G, with_labels=True, font_weight='bold')
  print("hello world")
make_fat_tree(1)

def make_jellyfish_topo(N, k, r):

  #k is the nuber of ports per switch
  #N is the number of switches
  #r is the number of ports per switch meant for other switches

  G = nx.random_regular_graph(r, N)
  nx.draw(G, with_labels=True, font_weight='bold')
  return G

def make_grid_2d_topo(m,n):
  #m and n are lenghts along the x and y dimensions
   G = nx.grid_2d_graph(m,n)
   nx.draw(G, with_labels=True, font_weight='bold')
   return G

def make_internet_AS_topo(n):
  #n is the number of nodes
  G = nx.random_internet_as_graph(n)
  nx.draw(G, with_labels=True, font_weight='bold')
  return G

#make_jellyfish_topo(10,5,5)
#make_grid_2d_topo(10,5)
make_internet_AS_topo(200)

import networkx as nx
import numpy as np
import matplotlib.pyplot as plt
import math
import random


def compute_cheeger_constant_deterministic(G):

    n = len(G.nodes)
    bitmap = [0 for _ in range(n)]

    return cheeger_constant(0, bitmap, G, n)


def cheeger_constant(index, bitmap, G, n):

    count = 0

    for i in range(n):
        count += bitmap[i]

    if count > int(n/2):
        return 1000000000

    if index == n:
        if count == 0:
            return 1000000000

        return get_cut_size(bitmap, G)/(count * 1.0)

    ans_wo = cheeger_constant(index+1, bitmap, G, n)

    bitmap[index] = 1
    ans_with = cheeger_constant(index+1, bitmap, G, n)
    bitmap[index] = 0

    return min(ans_wo, ans_with)

def estimate_cheeger_constant(G, rounds):
    n = len(G.nodes)
    cheeger = 1000000000

    for i in range(1, int(n/2)):

        sum_rounds = 0.0

        for _ in range(rounds):
            
            bitmap = get_random_bitmap(i, n)
            sum_rounds += get_edge_per_node_from_bitmap(bitmap, G, n)

        avg_of_rounds = sum_rounds/(1.0 * rounds)

        cheeger = min(cheeger, avg_of_rounds)

    return cheeger

def get_edge_per_node_from_bitmap(bitmap, G, n):

    count = 0

    for i in range(n):
        count += bitmap[i]
    
    if count == 0:
        return 1000000000

    num_edges = 0

    for edge in G.edges():
        if bitmap[edge[0]] + bitmap[edge[1]] == 1:
            num_edges += 1

    return num_edges/(1.0 * count)

def get_random_bitmap(i, n):

    bitmap = [0 for _ in range(n)]

    for i in range(n):
        if np.random.rand() < (i * 1.0)/n:
            bitmap[i] = 1

    count = 0
    for i in range(n):
        count += bitmap[i]
    
    if count == 0:
        return get_random_bitmap(i, n)

    return bitmap

def get_cut_size(bitmap, G):

    edge_count = 0
    for edge in G.edges:
        if bitmap[edge[0]] + bitmap[edge[1]] == 1:
            edge_count += 1

    return edge_count

def get_aggregate_edge_load_dict(G):

    shortest_path_dict = dict(nx.all_pairs_shortest_path(G))

    edge_counts = {}

    for key in shortest_path_dict:
        inner_dict = shortest_path_dict[key]

        for key2 in inner_dict:

            path = inner_dict[key2]
            p_len = len(path)

            for i in range(1, p_len):
                
                smaller = min(path[i-1], path[i])
                larger = max(path[i-1], path[i])

                edge = (smaller, larger)

                if edge not in edge_counts:
                    edge_counts[edge] = 0
                
                edge_counts[edge] += 1
        
    assert len(edge_counts.keys()) == len(G.edges), f"edge_counts_dict_key_count = {len(edge_counts.keys())}, #edges = {len(G.edges)}"

    return edge_counts

def compute_edge_load_distribution(edge_load_dict):

    count = 0
    num_edges = len(edge_load_dict.keys())

    for key in edge_load_dict:
        count += edge_load_dict[key]

    load_disbalance = 0.0
    max_load = -1

    for key in edge_load_dict:

        normalized_load = edge_load_dict[key]/(1.0 * count)

        max_load = max(max_load, normalized_load)

        load_disbalance += (1.0/num_edges - normalized_load)**2

    load_disbalance = math.sqrt(load_disbalance)

    return load_disbalance, max_load

def select_random_non_bridge(G):

    bridges = list(nx.bridges(Gb))
    edges = G.edges

    bridge_set = set(bridges)

    non_bridges = [x for x in edges if x not in bridge_set]

    length = len(non_bridges)

    return non_bridges[random.randint(length-1)]

def remove_random_non_bridge(G):

    assert nx.is_connected(G)

    non_bridge = select_random_non_bridge(G)

    G.remove_edge(*non_bridge)

# G.remove_edge(*e)


# print(estimate_cheeger_constant(G, 1000))
# print(compute_cheeger_constant_deterministic(G))
# G = nx.paley_graph(10)
Gc = nx.cycle_graph(20)
Gk = nx.complete_graph(30)
Gr = nx.gnp_random_graph(20, 0.7)
Gp = nx.path_graph(20)
Gs = nx.star_graph(20)
Gb = nx.barbell_graph(10, 0)

print(compute_edge_load_distribution(get_aggregate_edge_load_dict(Gc)))
print(estimate_cheeger_constant(Gc, 1000))

print(compute_edge_load_distribution(get_aggregate_edge_load_dict(Gk)))
print(estimate_cheeger_constant(Gk, 1000))

print(compute_edge_load_distribution(get_aggregate_edge_load_dict(Gr)))
print(estimate_cheeger_constant(Gr, 1000))

print(compute_edge_load_distribution(get_aggregate_edge_load_dict(Gp)))
print(estimate_cheeger_constant(Gp, 1000))

print(compute_edge_load_distribution(get_aggregate_edge_load_dict(Gs)))
print(estimate_cheeger_constant(Gs, 1000))

print(compute_edge_load_distribution(get_aggregate_edge_load_dict(Gb)))
print(estimate_cheeger_constant(Gb, 1000))

# print(list(nx.bridges(Gb)))
# print(Gb.edges)

# nx.draw(G)
# plt.show()

num_nodes = []
cheeger_as_graph = []
cheeger_grid_graph = []
cheeger_jelly = []
edges_as_graph = []
edges_jelly = []
max_load_as_graph = []
max_load_jelly = []
disbalance_as_graph = []
disbalance_jelly = []

for i in range(10, 201, 10):
  num_nodes.append(i)
  print(i)
  
  G_as = nx.random_internet_as_graph(i)
  G_jelly = nx.random_regular_graph(3, i)
  
  cheeger_as_graph.append(estimate_cheeger_constant(G_as, 200))
  cheeger_jelly.append(estimate_cheeger_constant(G_jelly, 200))

  edges_as_graph.append(len(list(G_as.edges)))
  edges_jelly.append(len(list(G_jelly.edges)))

  disb_as, load_as = compute_edge_load_distribution(get_aggregate_edge_load_dict(G_as))
  disb_jelly, load_jelly = compute_edge_load_distribution(get_aggregate_edge_load_dict(G_jelly))

  max_load_as_graph.append(load_as)
  max_load_jelly.append(load_jelly)
  disbalance_as_graph.append(disb_as)
  disbalance_jelly.append(disb_jelly)

plt.plot(num_nodes, cheeger_as_graph, color='red', label='Internet AS Topology')
plt.plot(num_nodes, cheeger_jelly, color='blue', label='Jellyfish Topology')

plt.xlabel(" Topology size")
plt.ylabel("Cheeger Constant")
plt.title("Quantifying the Network's Bottleneck")
plt.legend()

plt.show()

plt.plot(num_nodes, edges_as_graph, color='red', label='Internet AS Topology')
plt.plot(num_nodes, edges_jelly, color='blue', label='Jellyfish Topology')

plt.xlabel(" Topology size")
plt.ylabel("Network Resources")
plt.title("Network construction cost")
plt.legend()

plt.show()

plt.plot(num_nodes, max_load_as_graph, color='red', label='Internet AS Topology')
plt.plot(num_nodes, max_load_jelly, color='blue', label='Jellyfish Topology')

plt.xlabel(" Topology size")
plt.ylabel("Maximum Edge Load")
plt.title("Maximum Edge Load in Topology")
plt.legend()

plt.show()

plt.plot(num_nodes, disbalance_as_graph, color='red', label='Internet AS Topology')
plt.plot(num_nodes, disbalance_jelly, color='blue', label='Jellyfish Topology')

plt.xlabel(" Topology size")
plt.ylabel("Load Disbalance")
plt.title("Network Load Disbalance")
plt.legend()


plt.show()

num_nodes = []


for i in range(10, 201, 10):
  num_nodes.append(i)
  print(i)
  G_as = nx.random_internet_as_graph(i)
  G_grid = nx.grid_2d_graph(i,i)
  G_jelly = nx.random_regular_graph(3, i)
  cheeger_as_graph.append(estimate_cheeger_constant(G_as, 200))
  cheeger_jelly.append(estimate_cheeger_constant(G_jelly, 200))

  edges_as_graph.append(len(list(G_as.edges)))
  edges_jelly.append(len(list(G_jelly.edges)))

plt.plot(num_nodes, cheeger_as_graph, color='red', label='as_graph')x = []
y = []
z = []

for i in range(10, 501, 5):
  x.append(i)
  G = nx.random_internet_as_graph(i)
  disbalance, max_load =  compute_edge_load_distribution(get_aggregate_edge_load_dict(G))
  y.append(disbalance)
  z.append(max_load)

plt.plot(x,y)
plt.show()

plt.scatter(x,z)
plt.show()